# todo
# Compose v3 syntax works with Docker Desktop
version: "3.9"

services:
  # === PostgreSQL ===
  pg-ais:                            # service name (also the DNS name inside the compose network)
    image: postgres:18
    container_name: pg-ais           # same name that was used in run.sh earlier
    environment:
      POSTGRES_DB: order
      POSTGRES_USER: docker
      POSTGRES_PASSWORD: docker
      # Official Postgres images use this data path (not the /18/docker one)
      PGDATA: /var/lib/postgresql/data
    volumes:
      - pgdata_ais:/var/lib/postgresql/data
    ports:
      - "5432:5432"                  # connect from host as localhost:5432
    healthcheck:                     # so the app waits for DB to be ready
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 2s
      timeout: 3s
      retries: 20
    networks:
      - aisnet

  # === Go backend ===
  orderservice:
    build:
      context: .                     # folder with Dockerfile
      dockerfile: Dockerfile
    container_name: orderservice
    environment:
      # these are exactly what the Go code (db.go) reads:
      POSTGRES_DB: order
      POSTGRES_USER: docker
      POSTGRES_PASSWORD: docker
      POSTGRES_TCP_PORT: "5432"
      DB_HOST: pg-ais                # connect to the DB by service name
    ports:
      - "3000:3000"                  # app available at http://localhost:3000
    depends_on:
      pg-ais:
        condition: service_healthy   # wait for DB healthcheck to pass
    networks:
      - aisnet

volumes:
  pgdata_ais:                        # persistent DB data

networks:
  aisnet:
